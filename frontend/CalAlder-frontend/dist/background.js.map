{"version":3,"file":"background.js","sources":["../src/services/schema.js","../src/services/eventExtraction.js","../src/background.js"],"sourcesContent":["// schema.js\r\nexport const EVENT_SCHEMA = {\r\n    type: \"object\",\r\n    properties: {\r\n        events: {\r\n            type: \"array\",\r\n            minItems: 0,\r\n            items: {\r\n                type: \"object\",\r\n                additionalProperties: false,\r\n                properties: {\r\n                    title: { type: \"string\", minLength: 1 },\r\n                    startDate: { type: \"string\", pattern: \"^\\\\d{4}-\\\\d{2}-\\\\d{2}$\" },\r\n                    startTime: { type: [\"string\", \"null\"], pattern: \"^\\\\d{2}:\\\\d{2}(:\\\\d{2})?$\" },\r\n                    endDate: { type: [\"string\", \"null\"], pattern: \"^\\\\d{4}-\\\\d{2}-\\\\d{2}$\" },\r\n                    endTime: { type: [\"string\", \"null\"], pattern: \"^\\\\d{2}:\\\\d{2}(:\\\\d{2})?$\" },\r\n                    timezone: { type: [\"string\", \"null\"] },\r\n                    venue: { type: [\"string\", \"null\"] },\r\n                    address: { type: [\"string\", \"null\"] },\r\n                    city: { type: [\"string\", \"null\"] },\r\n                    country: { type: [\"string\", \"null\"] },\r\n                    url: { type: [\"string\", \"null\"] },\r\n                    notes: { type: [\"string\", \"null\"] },\r\n                },\r\n                required: [\"title\", \"startDate\"]\r\n            }\r\n        }\r\n    },\r\n    required: [\"events\"],\r\n    additionalProperties: false\r\n};","// eventExtraction.js\r\nimport { EVENT_SCHEMA } from './schema';\r\n\r\n// --- Original variable for session caching ---\r\nlet _sessionPromise = null;\r\nlet _session = null;\r\nlet _warmupStatus = null; // Track warmup status across tab sessions\r\n\r\n// --- Helper to check if Prompt API is available ---\r\nexport function promptApiSupported() {\r\n    return typeof globalThis.LanguageModel !== \"undefined\";\r\n}\r\n\r\n// --- Get current warmup status ---\r\nexport function getWarmupStatus() {\r\n    return _warmupStatus;\r\n}\r\n\r\n// --- Session creator for Chrome's LanguageModel API ---\r\n// Returns a single cached session per tab.\r\n// Also supports optional download progress monitoring.\r\nexport async function getSession(monitorHandlers) {\r\n    if (_session) {\r\n        console.log(\"[prompt_ai] Reusing existing model session\");\r\n        return _session;\r\n    }\r\n    if (_sessionPromise) {\r\n        console.log(\"[prompt_ai] Waiting for session creation in progress\");\r\n        return _sessionPromise;\r\n    }\r\n\r\n    _sessionPromise = (async () => {\r\n        if (!promptApiSupported()) {\r\n            const err = new Error(\"Chrome Prompt API is unavailable on this device/browser.\");\r\n            err.code = \"UNAVAILABLE\";\r\n            throw err;\r\n        }\r\n\r\n        const availability = await LanguageModel.availability();\r\n        if (availability === \"unavailable\") {\r\n            const err = new Error(\"Chrome Prompt API is unavailable on this device/browser.\");\r\n            err.code = \"UNAVAILABLE\";\r\n            throw err;\r\n        }\r\n\r\n        const monitor = monitorHandlers\r\n            ? (m) => {\r\n                let started = false;\r\n                m.addEventListener(\"downloadprogress\", (e) => {\r\n                    if (!started) {\r\n                        started = true;\r\n                        monitorHandlers.onStart?.();\r\n                    }\r\n                    monitorHandlers.onProgress?.(e.loaded); // 0..1 progress\r\n                    if (e.loaded >= 1) monitorHandlers.onDone?.();\r\n                });\r\n            }\r\n            : undefined;\r\n\r\n        console.log(\"[prompt_ai] Creating new model session...\");\r\n\r\n        // --- Create the model session once ---\r\n        // The session stays alive for the lifetime of the tab.\r\n        _session = await LanguageModel.create({\r\n            expectedInputs: [{ type: \"text\", languages: [\"en\"] }],\r\n            expectedOutputs: [{ type: \"text\", languages: [\"en\"] }],\r\n            temperature: 0.1, // Lower temperature for more deterministic outputs\r\n            topK: 1, // Reduce to 1 for fastest inference\r\n            monitor,\r\n            fastInference: true, // Enable fast inference mode\r\n        });\r\n\r\n        console.log(\"[prompt_ai] Model session created successfully\");\r\n\r\n        return _session;\r\n    })();\r\n\r\n    return _sessionPromise;\r\n}\r\n\r\n// --- Preload / prewarm model to download it early ---\r\n// This is called before first use to hide the long initial load time.\r\nexport async function prewarmModel(monitorHandlers) {\r\n    // If already warm or warming, skip\r\n    if (_warmupStatus === 'ready' || _warmupStatus === 'warming') {\r\n        return _sessionPromise;\r\n    }\r\n\r\n    _warmupStatus = 'warming';\r\n    try {\r\n        const session = await getSession({\r\n            onStart: () => {\r\n                _warmupStatus = 'warming';\r\n                monitorHandlers?.onStart?.();\r\n            },\r\n            onProgress: (p) => {\r\n                monitorHandlers?.onProgress?.(p);\r\n            },\r\n            onDone: () => {\r\n                _warmupStatus = 'ready';\r\n                monitorHandlers?.onDone?.();\r\n            }\r\n        });\r\n        _warmupStatus = 'ready';\r\n        return session;\r\n    } catch (e) {\r\n        _warmupStatus = 'failed';\r\n        throw e;\r\n    }\r\n}\r\n\r\n// --- Reset the session manually (rarely needed) ---\r\nexport function resetSession() {\r\n    _session = null;\r\n    _sessionPromise = null;\r\n}\r\n\r\n/**\r\n * Extracts event info (title, date, time, place, etc.) from a web page's text.\r\n * @param {string} pageText - The text content pulled from a page.\r\n * @returns {Promise<{events: Array<{\r\n *   title: string, startDate: string, startTime: string|null,\r\n *   endDate: string|null, endTime: string|null, timezone: string|null,\r\n *   venue: string|null, address: string|null, city: string|null, country: string|null,\r\n *   url: string|null, notes: string|null\r\n * }>>}>}\r\n */\r\nexport async function extractEvents(pageText, monitorHandlers = null) {\r\n    if (typeof pageText !== \"string\" || !pageText.trim()) {\r\n        return { events: [] };\r\n    }\r\n    // If running inside the extension and a background worker exists, route the prompt\r\n    // through the background service worker so the LanguageModel session can be cached\r\n    // in one long-lived context (avoids re-instantiation on popup/content loads).\r\n    // Route prompts through the background worker ONLY when running in a\r\n    // document context (popup or content script). In a background/service\r\n    // worker `window` is undefined; routing there would cause the worker to\r\n    // re-send messages to itself and drop the prompt. Ensure we only use\r\n    // chrome.runtime.sendMessage routing when `window` exists.\r\n    if (typeof window !== 'undefined' && typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {\r\n        // Use a request/response via chrome.runtime messages with a unique requestId.\r\n        const requestId = `req_${Date.now()}_${Math.floor(Math.random() * 1e6)}`;\r\n\r\n        console.log(\"[prompt_ai] Routing prompt via background\", { requestId });\r\n        return new Promise((resolve, reject) => {\r\n            // Listen for progress / result messages for this request\r\n            const onMessage = (msg, sender) => {\r\n                try {\r\n                    if (!msg || msg.requestId !== requestId) return;\r\n                    if (msg.type === 'PROMPT_PROGRESS') {\r\n                        // msg.progress is 0..1\r\n                        monitorHandlers?.onStart?.();\r\n                        monitorHandlers?.onProgress?.(msg.progress);\r\n                        if (msg.progress >= 1) monitorHandlers?.onDone?.();\r\n                        return;\r\n                    }\r\n                    if (msg.type === 'PROMPT_RESULT') {\r\n                        chrome.runtime.onMessage.removeListener(onMessage);\r\n                        if (msg.error) return resolve({ events: [] });\r\n                        // msg.result is expected to be an object { events: [...] }\r\n                        return resolve(msg.result || { events: [] });\r\n                    }\r\n                } catch (e) {\r\n                    // ignore handler errors\r\n                }\r\n            };\r\n\r\n            chrome.runtime.onMessage.addListener(onMessage);\r\n\r\n            // Send the request to background worker and also provide a callback to\r\n            // receive the final sendResponse result (background uses sendResponse()).\r\n            // We keep the onMessage listener to receive progress updates.\r\n            try {\r\n                chrome.runtime.sendMessage({ type: 'PROMPT_EXTRACT', requestId, text: pageText }, (resp) => {\r\n                    try {\r\n                        // Remove the progress listener once we get the final response\r\n                        chrome.runtime.onMessage.removeListener(onMessage);\r\n                    } catch (e) { }\r\n\r\n                    if (chrome.runtime.lastError) {\r\n                        return resolve({ events: [] });\r\n                    }\r\n\r\n                    // Background sends the final payload via sendResponse as an object\r\n                    // shaped like { type: 'PROMPT_RESULT', requestId, result } or { type: 'PROMPT_RESULT', requestId, error }\r\n                    if (!resp) return resolve({ events: [] });\r\n\r\n                    if (resp.type === 'PROMPT_RESULT' && resp.requestId === requestId) {\r\n                        if (resp.error) return resolve({ events: [] });\r\n                        return resolve(resp.result || { events: [] });\r\n                    }\r\n\r\n                    // Fallback: resolve empty\r\n                    return resolve({ events: [] });\r\n                });\r\n            } catch (e) {\r\n                try { chrome.runtime.onMessage.removeListener(onMessage); } catch (e) { }\r\n                return resolve({ events: [] });\r\n            }\r\n        });\r\n    }\r\n\r\n    // Fallback to local/session prompt in this context\r\n    const session = await getSession(monitorHandlers);\r\n\r\n    // Structure the message to be very explicit about the task\r\n    const messages = [\r\n        {\r\n            role: \"system\",\r\n            content: GUIDANCE_PROMPT\r\n        },\r\n        {\r\n            role: \"user\",\r\n            content: `TEXT TO ANALYZE:\r\n---START---\r\n${pageText}\r\n---END---\r\n\r\nREQUIRED: Extract any events from the above text and return them in valid JSON format matching the schema exactly.\r\nIf no valid events are found, return {\"events\":[]}.\r\nReturn ONLY the JSON, no other text.`\r\n        }\r\n    ];\r\n\r\n    let raw;\r\n    try {\r\n        console.log(\"[prompt_ai] Preparing to call model with:\", {\r\n            textLength: pageText.length,\r\n            preview: pageText.slice(0, 100) + \"...\",\r\n            timestamp: new Date().toISOString()\r\n        });\r\n\r\n        // Track start time for performance monitoring\r\n        const startTime = performance.now();\r\n\r\n        // --- Call the local model to generate JSON per EVENT_SCHEMA ---\r\n        // NOTE: removed the hard 30s timeout to avoid prematurely aborting\r\n        // longer-running model inferences. The caller may implement its own\r\n        // cancellation if desired via session-level APIs.\r\n        console.log('[prompt_ai] Invoking session.prompt (no hard timeout)');\r\n        raw = await session.prompt(messages, {\r\n            responseConstraint: EVENT_SCHEMA,\r\n            // Explicitly tell the model to return JSON only\r\n            outputFormat: \"json\",\r\n            // Set required output language to avoid warnings\r\n            expectedOutputs: [{ type: \"text\", languages: [\"en\"] }],\r\n            // Keeps the schema enforced without injecting it into the model's input\r\n            omitResponseConstraintInput: true,\r\n            // Use fast inference with lower temperature for more focused responses\r\n            fastInference: true,\r\n            temperature: 0.01 // Very low temperature to ensure consistent, focused responses\r\n        });\r\n\r\n        const duration = performance.now() - startTime;\r\n        console.log(\"[prompt_ai] Model response received:\", {\r\n            duration: `${duration.toFixed(2)}ms`,\r\n            responseLength: raw?.length || 0,\r\n            preview: raw?.slice(0, 100) + \"...\",\r\n            timestamp: new Date().toISOString()\r\n        });\r\n\r\n    } catch (e) {\r\n        // --- If model fails to return valid JSON, return empty result ---\r\n        console.error(\"[prompt_ai] Prompt error:\", {\r\n            error: e.message,\r\n            stack: e.stack,\r\n            timestamp: new Date().toISOString()\r\n        });\r\n        return { events: [] };\r\n    }\r\n\r\n    try {\r\n        const data = JSON.parse(raw);\r\n        console.log(\"[prompt_ai] Parsed response:\", {\r\n            hasEvents: !!data?.events,\r\n            eventCount: data?.events?.length || 0,\r\n            timestamp: new Date().toISOString()\r\n        });\r\n\r\n        // --- Sanity check: ensure result matches expected structure ---\r\n        if (!data || typeof data !== \"object\" || !Array.isArray(data.events)) {\r\n            console.warn(\"[prompt_ai] Invalid response structure:\", {\r\n                rawResponse: raw,\r\n                timestamp: new Date().toISOString()\r\n            });\r\n            return { events: [] };\r\n        }\r\n        return data;\r\n    } catch (e) {\r\n        console.error(\"[prompt_ai] JSON parse error:\", {\r\n            error: e.message,\r\n            rawResponse: raw,\r\n            timestamp: new Date().toISOString()\r\n        });\r\n        return { events: [] };\r\n    }\r\n}\r\n\r\n/**\r\n * Combines warm-up and extraction in one call.\r\n * Equivalent to: await ensureModelReady(); then await extractEvents(text);\r\n */\r\nexport async function extractEventsReady(pageText, monitorHandlers = null) {\r\n    await prewarmModel(monitorHandlers);\r\n    return extractEvents(pageText, monitorHandlers);\r\n}\r\n\r\nexport const GUIDANCE_PROMPT = `TASK: Extract calendar event details from the given text and format them as structured JSON.\r\n\r\nINSTRUCTIONS:\r\n1. Look for event information including:\r\n   - Event title/name\r\n   - Date(s) and time(s)\r\n   - Location details\r\n   - Additional details like description/URL\r\n\r\n2. For each event found, format the data according to this exact schema:\r\n{\r\n    \"events\": [\r\n        {\r\n            \"title\": \"(required) event name/title\",\r\n            \"startDate\": \"(required) YYYY-MM-DD format\",\r\n            \"startTime\": \"HH:MM format or null\",\r\n            \"endDate\": \"YYYY-MM-DD format or null\",\r\n            \"endTime\": \"HH:MM format or null\",\r\n            \"timezone\": \"IANA timezone (e.g., America/Los_Angeles) or null\",\r\n            \"venue\": \"location name or null\",\r\n            \"address\": \"street address or null\",\r\n            \"city\": \"city name or null\",\r\n            \"country\": \"country name or null\",\r\n            \"url\": \"event URL or null\",\r\n            \"notes\": \"additional details or null\"\r\n        }\r\n    ]\r\n}\r\n\r\n3. Data Requirements:\r\n   - title and startDate are REQUIRED\r\n   - Other fields can be null if not found\r\n   - Dates must be YYYY-MM-DD format\r\n   - Times must be HH:MM format\r\n   - Return {\"events\":[]} if no valid events found\r\n\r\nIMPORTANT:\r\n- Focus ONLY on extracting events\r\n- Return ONLY valid JSON matching the schema exactly\r\n- Do not add explanations or extra text\r\n- Do not create fictional data; use only information present in the text`.trim();","// Track which tabs have content scripts loaded\r\nconst loadedTabs = new Set();\r\n\r\nchrome.runtime.onInstalled.addListener(() => {\r\n  console.log(\"CalAIder installed and ready!\");\r\n});\r\n\r\n// Listen for tab updates to track content script status\r\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\r\n  if (changeInfo.status === 'complete' && tab.url && tab.url.startsWith('http')) {\r\n    chrome.scripting.executeScript({\r\n      target: { tabId: tabId },\r\n      files: ['content.js']\r\n    }).then(() => {\r\n      loadedTabs.add(tabId);\r\n      console.log(`Content script loaded in tab ${tabId}`);\r\n    }).catch(err => {\r\n      console.error(`Failed to inject content script in tab ${tabId}:`, err);\r\n    });\r\n  }\r\n});\r\n\r\n// Clean up when tabs are closed\r\nchrome.tabs.onRemoved.addListener((tabId) => {\r\n  loadedTabs.delete(tabId);\r\n});\r\n\r\n// Handle communication between popup and content script\r\n// NOTE: import the eventExtraction service statically to avoid Vite's DOM-dependent\r\n// preload wrapper which fails inside service workers (no `window` / `document`).\r\nimport * as svc from './services/eventExtraction.js';\r\n\r\n// Keep track of whether session is warm to reduce unnecessary recreations\r\nlet sessionWarmedUp = false;\r\n\r\n// Try to prewarm the on-device model when the background worker starts up\r\n// (or when the extension is installed). This reduces the latency for the\r\n// first user extraction because the model download/compile happens ahead of time.\r\nconst tryPrewarmBackground = async () => {\r\n  if (sessionWarmedUp) {\r\n    console.log('[CalAIder] Session already warmed up, skipping prewarm');\r\n    return;\r\n  }\r\n  try {\r\n    console.log('[CalAIder] Background attempting to prewarm model...');\r\n    await svc.prewarmModel({\r\n      onStart: () => console.log('[CalAIder] Model prewarm started'),\r\n      onProgress: (p) => console.log('[CalAIder] Model prewarm progress', p),\r\n      onDone: () => {\r\n        console.log('[CalAIder] Model prewarm done');\r\n        sessionWarmedUp = true;\r\n      }\r\n    });\r\n    sessionWarmedUp = true;\r\n    console.log('[CalAIder] Background model prewarm complete');\r\n  } catch (e) {\r\n    console.warn('[CalAIder] Background prewarm failed or not available:', e?.message || e);\r\n  }\r\n};\r\n\r\nchrome.runtime.onInstalled.addListener(() => {\r\n  tryPrewarmBackground();\r\n});\r\n\r\n// Also attempt prewarm when the service worker starts (onStartup)\r\nif (chrome.runtime.onStartup) {\r\n  chrome.runtime.onStartup.addListener(() => {\r\n    tryPrewarmBackground();\r\n  });\r\n}\r\n\r\n// ----- Background Analysis Session Management -----\r\n// Tracks active analysis per URL; continues even when popup closes\r\nconst activeAnalyses = new Map(); // url -> { cancel: AbortController, promise: Promise }\r\n\r\n// Keep service worker alive during active analysis\r\nlet keepaliveInterval = null;\r\nconst startKeepalive = () => {\r\n  if (keepaliveInterval) return;\r\n  keepaliveInterval = setInterval(() => {\r\n    // Ping to keep service worker alive\r\n    console.log('[CalAIder BG] Keepalive ping');\r\n  }, 20000); // Every 20 seconds\r\n};\r\nconst stopKeepalive = () => {\r\n  if (keepaliveInterval) {\r\n    clearInterval(keepaliveInterval);\r\n    keepaliveInterval = null;\r\n  }\r\n};\r\n\r\n// Helper: date correction for past dates\r\nconst correctPastDate = (dateStr) => {\r\n  if (!dateStr || !/^\\d{4}-\\d{2}-\\d{2}$/.test(dateStr)) return dateStr;\r\n  const eventDate = new Date(dateStr);\r\n  const now = new Date();\r\n  const daysDiff = Math.floor((now - eventDate) / (1000 * 60 * 60 * 24));\r\n  if (daysDiff > 30) {\r\n    const currentYear = now.getFullYear();\r\n    const [year, month, day] = dateStr.split('-');\r\n    const correctedDate = `${currentYear}-${month}-${day}`;\r\n    const correctedDateTime = new Date(correctedDate);\r\n    if (correctedDateTime < now) {\r\n      return `${currentYear + 1}-${month}-${day}`;\r\n    }\r\n    return correctedDate;\r\n  }\r\n  return dateStr;\r\n};\r\n\r\n// Helper: get event key for deduplication\r\nconst getEventKey = (ev) => (\r\n  `${ev?.title || ev?.summary || ''}|${ev?.startDate || ''}|${ev?.location || ev?.address || ''}`\r\n).toLowerCase();\r\n\r\n// Helper: aggregate session events with deduplication\r\nconst aggregateSessionEvents = (session) => {\r\n  if (!session) return [];\r\n  const all = [];\r\n  const seen = new Set();\r\n  const sections = session.eventsPerSection || {};\r\n  const completed = Array.isArray(session.completedIndices) ? new Set(session.completedIndices) : new Set();\r\n  for (const [idx, evts] of Object.entries(sections)) {\r\n    if (!completed.has(Number(idx))) continue;\r\n    (evts || []).forEach(ev => {\r\n      const key = getEventKey(ev);\r\n      if (seen.has(key)) return;\r\n      seen.add(key);\r\n      all.push(ev);\r\n    });\r\n  }\r\n  return all;\r\n};\r\n\r\n// Broadcast progress update to any listening popup/contexts\r\nconst broadcastProgress = (url, update) => {\r\n  try {\r\n    chrome.runtime.sendMessage({ type: 'ANALYSIS_PROGRESS', url, ...update });\r\n  } catch (e) {\r\n    // Popup may be closed; that's OK\r\n  }\r\n};\r\n\r\n// Background analysis loop: runs section-by-section, persists progress, survives popup close\r\nconst runBackgroundAnalysis = async (url, items, forceRefresh = false) => {\r\n  console.log(`[CalAIder BG] Starting analysis for ${url}, ${items.length} sections`);\r\n\r\n  // Start keepalive to prevent service worker termination during analysis\r\n  startKeepalive();\r\n\r\n  // Load or create session\r\n  const sessionData = await new Promise((resolve) => {\r\n    chrome.storage.local.get(['analysisSessions'], (data) => {\r\n      const sessions = data?.analysisSessions || {};\r\n      resolve(sessions[url] || null);\r\n    });\r\n  });\r\n\r\n  let session = sessionData;\r\n  if (!session || forceRefresh) {\r\n    session = {\r\n      items,\r\n      totalItems: items.length,\r\n      completedIndices: [],\r\n      eventsPerSection: {},\r\n      isRunning: true,\r\n      startedAt: Date.now(),\r\n    };\r\n  } else {\r\n    if (!Array.isArray(session.items) || session.items.length === 0) {\r\n      session.items = items;\r\n      session.totalItems = items.length;\r\n    }\r\n    session.isRunning = true;\r\n  }\r\n\r\n  // Save session\r\n  await new Promise((resolve) => {\r\n    chrome.storage.local.get(['analysisSessions'], (data) => {\r\n      const sessions = data?.analysisSessions || {};\r\n      sessions[url] = { ...session, lastUpdated: Date.now() };\r\n      chrome.storage.local.set({ analysisSessions: sessions }, resolve);\r\n    });\r\n  });\r\n\r\n  const abortController = new AbortController();\r\n  const signal = abortController.signal;\r\n  activeAnalyses.set(url, { cancel: abortController });\r\n\r\n  broadcastProgress(url, {\r\n    currentItem: session.completedIndices.length,\r\n    totalItems: session.totalItems,\r\n    status: 'Starting analysis...',\r\n    modelProgress: session.totalItems ? (session.completedIndices.length / session.totalItems) : 0\r\n  });\r\n\r\n  try {\r\n    for (let i = 0; i < session.items.length; i++) {\r\n      if (signal.aborted) throw new Error('Analysis cancelled');\r\n\r\n      // Skip already completed sections\r\n      if (Array.isArray(session.completedIndices) && session.completedIndices.includes(i)) {\r\n        continue;\r\n      }\r\n\r\n      const item = session.items[i] || {};\r\n      broadcastProgress(url, {\r\n        currentItem: i + 1,\r\n        totalItems: session.totalItems,\r\n        status: `Analyzing section ${i + 1} of ${session.totalItems}...`,\r\n        modelProgress: i / Math.max(1, session.totalItems)\r\n      });\r\n\r\n      const inputText = typeof item === 'string'\r\n        ? item\r\n        : (item.title || item.description || item.text || JSON.stringify(item));\r\n\r\n      if (i > 0) await new Promise(resolve => setTimeout(resolve, 500));\r\n\r\n      let result = null;\r\n      try {\r\n        result = await svc.extractEventsReady(inputText, {\r\n          onStart: () => console.log(`[CalAIder BG] Section ${i + 1} started`),\r\n          onProgress: (p) => {\r\n            broadcastProgress(url, {\r\n              currentItem: i + 1,\r\n              totalItems: session.totalItems,\r\n              status: `Analyzing section ${i + 1} (${Math.round((p || 0) * 100)}%)...`,\r\n              modelProgress: (i + (p || 0)) / session.totalItems\r\n            });\r\n          },\r\n          onDone: () => console.log(`[CalAIder BG] Section ${i + 1} done`)\r\n        });\r\n      } catch (err) {\r\n        console.error(`[CalAIder BG] Section ${i + 1} failed:`, err);\r\n        continue;\r\n      }\r\n\r\n      if (result?.events?.length) {\r\n        const correctedEvents = result.events.map(ev => ({\r\n          ...ev,\r\n          startDate: correctPastDate(ev.startDate),\r\n          endDate: ev.endDate ? correctPastDate(ev.endDate) : ev.endDate\r\n        }));\r\n        session.eventsPerSection = session.eventsPerSection || {};\r\n        session.eventsPerSection[i] = correctedEvents;\r\n        session.completedIndices = Array.from(new Set([...(session.completedIndices || []), i]));\r\n\r\n        // Save session progress\r\n        await new Promise((resolve) => {\r\n          chrome.storage.local.get(['analysisSessions'], (data) => {\r\n            const sessions = data?.analysisSessions || {};\r\n            sessions[url] = { ...session, lastUpdated: Date.now() };\r\n            chrome.storage.local.set({ analysisSessions: sessions }, resolve);\r\n          });\r\n        });\r\n\r\n        // Aggregate and save to cache\r\n        const agg = aggregateSessionEvents(session);\r\n        await new Promise((resolve) => {\r\n          chrome.storage.local.get(['detectedEventsCache'], (data) => {\r\n            const cache = data?.detectedEventsCache || {};\r\n            cache[url] = { events: agg, timestamp: Date.now() };\r\n            chrome.storage.local.set({ detectedEventsCache: cache }, resolve);\r\n          });\r\n        });\r\n\r\n        broadcastProgress(url, {\r\n          currentItem: i + 1,\r\n          totalItems: session.totalItems,\r\n          status: `Found ${result.events.length} events in section ${i + 1}`,\r\n          modelProgress: (i + 1) / session.totalItems,\r\n          detectedEvents: agg\r\n        });\r\n      }\r\n    }\r\n\r\n    // Fallback full-page extraction if no events found\r\n    const dedupedEvents = aggregateSessionEvents(session);\r\n    if (dedupedEvents.length === 0) {\r\n      broadcastProgress(url, { status: 'No events in sections, trying full-page extraction...' });\r\n      try {\r\n        const fullText = session.items.map(item =>\r\n          typeof item === 'string' ? item : (item.title || item.description || item.text || JSON.stringify(item))\r\n        ).join('\\n\\n');\r\n\r\n        const fullResult = await svc.extractEventsReady(fullText, {\r\n          onStart: () => broadcastProgress(url, { status: 'Running full-page extraction...' }),\r\n          onProgress: (p) => broadcastProgress(url, { modelProgress: p }),\r\n          onDone: () => { }\r\n        });\r\n\r\n        if (fullResult?.events?.length) {\r\n          const correctedEvents = fullResult.events.map(ev => ({\r\n            ...ev,\r\n            startDate: correctPastDate(ev.startDate),\r\n            endDate: ev.endDate ? correctPastDate(ev.endDate) : ev.endDate\r\n          }));\r\n          session.eventsPerSection[-1] = correctedEvents;\r\n          session.completedIndices.push(-1);\r\n\r\n          const agg2 = aggregateSessionEvents(session);\r\n          await new Promise((resolve) => {\r\n            chrome.storage.local.get(['detectedEventsCache'], (data) => {\r\n              const cache = data?.detectedEventsCache || {};\r\n              cache[url] = { events: agg2, timestamp: Date.now() };\r\n              chrome.storage.local.set({ detectedEventsCache: cache }, resolve);\r\n            });\r\n          });\r\n\r\n          broadcastProgress(url, {\r\n            status: `Found ${correctedEvents.length} events (full-page)`,\r\n            detectedEvents: agg2\r\n          });\r\n        }\r\n      } catch (e) {\r\n        console.error('[CalAIder BG] Full-page extraction failed:', e);\r\n      }\r\n    }\r\n\r\n    // Mark session complete\r\n    session.isRunning = false;\r\n    await new Promise((resolve) => {\r\n      chrome.storage.local.get(['analysisSessions'], (data) => {\r\n        const sessions = data?.analysisSessions || {};\r\n        sessions[url] = { ...session, lastUpdated: Date.now() };\r\n        chrome.storage.local.set({ analysisSessions: sessions }, resolve);\r\n      });\r\n    });\r\n\r\n    broadcastProgress(url, {\r\n      status: 'Analysis complete!',\r\n      modelProgress: 1,\r\n      isExtracting: false,\r\n      detectedEvents: aggregateSessionEvents(session)\r\n    });\r\n\r\n  } catch (err) {\r\n    if (!signal.aborted) {\r\n      console.error('[CalAIder BG] Analysis error:', err);\r\n      broadcastProgress(url, { status: `Error: ${err.message}`, isExtracting: false });\r\n    }\r\n  } finally {\r\n    activeAnalyses.delete(url);\r\n    // Stop keepalive if no more active analyses\r\n    if (activeAnalyses.size === 0) {\r\n      stopKeepalive();\r\n    }\r\n  }\r\n};\r\n\r\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\r\n  if (request.type === 'PING_CONTENT_SCRIPT') {\r\n    chrome.tabs.query({ active: true, currentWindow: true }, async (tabs) => {\r\n      if (!tabs[0]?.id) {\r\n        sendResponse({ error: 'No active tab found' });\r\n        return;\r\n      }\r\n\r\n      const tabId = tabs[0].id;\r\n\r\n      try {\r\n        // Check if content script needs to be injected\r\n        if (!loadedTabs.has(tabId)) {\r\n          await chrome.scripting.executeScript({\r\n            target: { tabId },\r\n            files: ['content.js']\r\n          });\r\n          loadedTabs.add(tabId);\r\n        }\r\n\r\n        // Try to communicate with the content script\r\n        chrome.tabs.sendMessage(tabId, { type: 'PING' }, (response) => {\r\n          if (chrome.runtime.lastError) {\r\n            loadedTabs.delete(tabId); // Mark as unloaded\r\n            sendResponse({ error: 'Content script not responding' });\r\n          } else {\r\n            sendResponse({ status: 'content_script_ready' });\r\n          }\r\n        });\r\n      } catch (err) {\r\n        console.error('Error checking content script:', err);\r\n        sendResponse({ error: err.message || 'Failed to check content script' });\r\n      }\r\n    });\r\n    return true; // Keep the message channel open for async response\r\n  }\r\n\r\n  // Start background analysis\r\n  if (request.type === 'START_ANALYSIS') {\r\n    const { url, items, forceRefresh } = request;\r\n    if (activeAnalyses.has(url)) {\r\n      sendResponse({ status: 'already_running' });\r\n      return true;\r\n    }\r\n    runBackgroundAnalysis(url, items, forceRefresh).catch(err => {\r\n      console.error('[CalAIder BG] Analysis failed:', err);\r\n    });\r\n    sendResponse({ status: 'started' });\r\n    return true;\r\n  }\r\n\r\n  // Cancel background analysis\r\n  if (request.type === 'CANCEL_ANALYSIS') {\r\n    const { url } = request;\r\n    const active = activeAnalyses.get(url);\r\n    if (active) {\r\n      active.cancel.abort();\r\n      activeAnalyses.delete(url);\r\n      // Mark session as not running\r\n      chrome.storage.local.get(['analysisSessions'], (data) => {\r\n        const sessions = data?.analysisSessions || {};\r\n        if (sessions[url]) {\r\n          sessions[url].isRunning = false;\r\n          chrome.storage.local.set({ analysisSessions: sessions });\r\n        }\r\n      });\r\n      sendResponse({ status: 'cancelled' });\r\n    } else {\r\n      sendResponse({ status: 'not_running' });\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // Get analysis status\r\n  if (request.type === 'GET_ANALYSIS_STATUS') {\r\n    const { url } = request;\r\n    const isRunning = activeAnalyses.has(url);\r\n    chrome.storage.local.get(['analysisSessions'], (data) => {\r\n      const sessions = data?.analysisSessions || {};\r\n      const session = sessions[url];\r\n      sendResponse({\r\n        isRunning,\r\n        session: session || null,\r\n        detectedEvents: session ? aggregateSessionEvents(session) : []\r\n      });\r\n    });\r\n    return true;\r\n  }\r\n\r\n  // Handle prompt requests from other contexts and run them in background\r\n  if (request.type === 'PROMPT_EXTRACT') {\r\n    (async () => {\r\n      const { requestId, text } = request;\r\n      try {\r\n        // Use the statically imported service module to perform extraction here\r\n        // Define handlers that forward progress events back to the requester\r\n        const monitor = {\r\n          onStart: () => {\r\n            try { chrome.runtime.sendMessage({ type: 'PROMPT_PROGRESS', requestId, progress: 0 }); } catch (e) { }\r\n          },\r\n          onProgress: (p) => {\r\n            try { chrome.runtime.sendMessage({ type: 'PROMPT_PROGRESS', requestId, progress: p }); } catch (e) { }\r\n          },\r\n          onDone: () => {\r\n            try { chrome.runtime.sendMessage({ type: 'PROMPT_PROGRESS', requestId, progress: 1 }); } catch (e) { }\r\n          }\r\n        };\r\n\r\n        const result = await svc.extractEvents(text, monitor);\r\n\r\n        // Send final result\r\n        sendResponse({ type: 'PROMPT_RESULT', requestId, result });\r\n      } catch (e) {\r\n        console.error('[CalAIder] Background prompt failed:', e);\r\n        sendResponse({ type: 'PROMPT_RESULT', requestId, error: e.message });\r\n      }\r\n    })();\r\n    return true; // async\r\n  }\r\n});\r\n\r\n\r\n"],"names":["e","svc.prewarmModel","svc.extractEventsReady","svc.extractEvents"],"mappings":"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"}