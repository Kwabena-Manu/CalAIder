{"version":3,"file":"content.js","sources":["../src/content/content.js"],"sourcesContent":["// content.js - Event extractor that runs in page context\r\n// Extracts structured event data and formats it for AI processing\r\n\r\n(function () {\r\n    // Notify that content script is loaded\r\n    console.log('[CalAIder] Content script loaded and initialized');\r\n\r\n    // Register script load with background\r\n    try {\r\n        chrome.runtime.sendMessage({\r\n            type: 'CONTENT_SCRIPT_LOADED',\r\n            tabId: window.location.href\r\n        });\r\n    } catch (err) {\r\n        console.error('[CalAIder] Failed to notify background script:', err);\r\n    }\r\n\r\n    function cleanText(text) {\r\n        if (!text) return '';\r\n        // Remove template placeholders\r\n        text = text.replace(/\\[[a-zA-Z_]+\\]/g, '');\r\n        // Remove excessive whitespace\r\n        text = text.replace(/\\s+/g, ' ');\r\n        // Remove empty lines\r\n        text = text.split('\\n').filter(line => line.trim()).join('\\n');\r\n        return text.trim();\r\n    }\r\n\r\n    function extractStructuredData() {\r\n        const events = [];\r\n\r\n        // Extract JSON-LD\r\n        const jsonLdNodes = document.querySelectorAll('script[type=\"application/ld+json\"]');\r\n        jsonLdNodes.forEach(node => {\r\n            try {\r\n                const data = JSON.parse(node.textContent);\r\n                if (data && (data['@type'] === 'Event' || (Array.isArray(data) && data.some(item => item['@type'] === 'Event')))) {\r\n                    events.push(data);\r\n                }\r\n            } catch (e) {\r\n                console.warn('[CalAIder] Failed to parse JSON-LD:', e);\r\n            }\r\n        });\r\n\r\n        // Extract Schema.org Microdata\r\n        const microDataNodes = document.querySelectorAll('[itemtype*=\"Event\"]');\r\n        microDataNodes.forEach(node => {\r\n            const event = {\r\n                title: node.querySelector('[itemprop=\"name\"]')?.content || node.querySelector('[itemprop=\"name\"]')?.textContent,\r\n                startDate: node.querySelector('[itemprop=\"startDate\"]')?.content,\r\n                endDate: node.querySelector('[itemprop=\"endDate\"]')?.content,\r\n                location: node.querySelector('[itemprop=\"location\"]')?.textContent,\r\n                description: node.querySelector('[itemprop=\"description\"]')?.textContent\r\n            };\r\n            if (event.title) events.push(event);\r\n        });\r\n\r\n        return events;\r\n    }\r\n\r\n    function extractEventContent() {\r\n        const eventSections = document.querySelectorAll(\r\n            '.event, .events, [class*=\"event-\"], [class*=\"calendar-\"], ' +\r\n            'article, .article, .post, [role=\"article\"], ' +\r\n            '[class*=\"event_\"], [id*=\"event-\"]'\r\n        );\r\n\r\n        return Array.from(eventSections).map(section => {\r\n            const titleEl = section.querySelector('h1,h2,h3,h4,[class*=\"title\"],[class*=\"heading\"]');\r\n            const dateEl = section.querySelector('time,[class*=\"date\"],[class*=\"time\"],[datetime]');\r\n            const locationEl = section.querySelector('[class*=\"location\"],[class*=\"venue\"],[class*=\"place\"],[class*=\"address\"]');\r\n\r\n            return {\r\n                title: cleanText(titleEl?.textContent),\r\n                date: cleanText(dateEl?.textContent || dateEl?.getAttribute('datetime')),\r\n                location: cleanText(locationEl?.textContent),\r\n                description: cleanText(section.textContent)\r\n            };\r\n        });\r\n    }\r\n\r\n    function extractPageContent() {\r\n        console.log('[CalAIder] Starting content extraction...');\r\n\r\n        // Priority 1: Try structured data first\r\n        const structuredEvents = extractStructuredData();\r\n        if (structuredEvents.length > 0) {\r\n            const data = {\r\n                type: 'structured',\r\n                content: structuredEvents\r\n            };\r\n            console.log('[CalAIder] Found structured data:', data);\r\n            return JSON.stringify(data);\r\n        }\r\n\r\n        // Priority 2: Look for specific event sections\r\n        const eventSections = document.querySelectorAll(\r\n            '.event, .events, [class*=\"event-\"], [class*=\"calendar-\"]'\r\n        );\r\n\r\n        if (eventSections.length > 0) {\r\n            const eventTexts = Array.from(eventSections).map(section => ({\r\n                title: section.querySelector('h1,h2,h3')?.innerText?.trim() || '',\r\n                date: section.querySelector('time,[class*=\"date\"],[class*=\"time\"]')?.innerText?.trim() || '',\r\n                location: section.querySelector('[class*=\"location\"],[class*=\"venue\"]')?.innerText?.trim() || '',\r\n                description: section.innerText?.trim() || ''\r\n            })).filter(event => event.title || event.date);\r\n\r\n            const data = {\r\n                type: 'extracted',\r\n                content: eventTexts,\r\n                size: JSON.stringify(eventTexts).length\r\n            };\r\n\r\n            console.log('[CalAIder] Found event sections:', data);\r\n\r\n            // Limit size to avoid quota errors (50KB limit)\r\n            if (data.size > 50000) {\r\n                console.warn('[CalAIder] Content exceeds 50KB, truncating...');\r\n                data.content = data.content.slice(0, 3); // Keep only first 3 events\r\n            }\r\n\r\n            return JSON.stringify(data);\r\n        }\r\n\r\n        // Priority 3: Get main content area\r\n        const mainContent = document.querySelector('main,article,#content,#main');\r\n        if (mainContent) {\r\n            const text = mainContent.innerText.trim();\r\n            const data = {\r\n                type: 'main_content',\r\n                content: text.slice(0, 50000), // Limit to 50KB\r\n                size: text.length\r\n            };\r\n            console.log('[CalAIder] Using main content:', data);\r\n            return JSON.stringify(data);\r\n        }\r\n\r\n        // Last resort: Get minimal body text\r\n        const minimalText = document.body.innerText.slice(0, 25000); // Even smaller limit\r\n        const data = {\r\n            type: 'body_text',\r\n            content: minimalText,\r\n            size: minimalText.length\r\n        };\r\n        console.log('[CalAIder] Falling back to body text:', data);\r\n        return JSON.stringify(data);\r\n    }\r\n\r\n    // Set up message listener\r\n    chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\r\n        console.log('[CalAIder] Received message:', request.type);\r\n\r\n        // Handle ping to check if content script is alive\r\n        if (request.type === 'PING') {\r\n            console.log('[CalAIder] Responding to ping');\r\n            sendResponse({ status: 'content_script_ready' });\r\n            return true;\r\n        }\r\n\r\n        // Handle text extraction\r\n        if (request.type === 'EXTRACT_TEXT') {\r\n            const content = extractPageContent();\r\n            console.log('[CalAIder] Extracted content');\r\n\r\n            // Persist the extracted page content for debugging/inspection\r\n            try {\r\n                // Try to parse structured JSON if possible so storage is structured\r\n                let parsed = null;\r\n                try {\r\n                    parsed = JSON.parse(content);\r\n                } catch (e) {\r\n                    // not JSON, leave parsed null\r\n                }\r\n\r\n                const payload = parsed && (parsed.type && parsed.content)\r\n                    ? { type: parsed.type, items: parsed.content }\r\n                    : { type: 'raw', text: typeof content === 'string' ? content.slice(0, 20000) : String(content) };\r\n\r\n                chrome.storage.local.set({\r\n                    lastPageExtraction: {\r\n                        payload,\r\n                        raw: typeof content === 'string' ? content.slice(0, 20000) : String(content),\r\n                        timestamp: Date.now()\r\n                    }\r\n                }, () => {\r\n                    console.log('[CalAIder] Saved page extraction to chrome.storage.local');\r\n                });\r\n            } catch (e) {\r\n                console.error('[CalAIder] Failed to save page extraction to storage:', e);\r\n            }\r\n\r\n            sendResponse({ text: content });\r\n            return true;\r\n        }\r\n    });\r\n})();"],"names":["data"],"mappings":"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"}